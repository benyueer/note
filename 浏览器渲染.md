### 页面渲染过程

#### 主要过程
1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。

**注意**：
1. 这5步并不一定是按顺序一次性完成的，当CSSOM或DOM被CSS或js修改时，以上步骤就会重复执行
2. 关键渲染路径要求必须同时具有DOM和CSSOM才会构建渲染树

#### 阻塞渲染
##### CSS阻塞渲染
1. 因为CSS被视为阻塞渲染的资源，所以浏览器在CSSOM构建完毕之前，不会渲染任何已处理的内容。
2. CSSOM 构建时，JavaScript执行将暂停，直到CSSOM 就绪。
3. CSS 不会阻塞HTML的解析,但是会阻塞渲染树的构建
所以我们需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。 也就是说，我们尽量把引入css的标签放在head标签内。

**⚠️**：
1. DOM解析和CSS解析是并行的过程，所以CSSOM解析不会阻塞DOM解析
2. 但是render tree依赖DOM tree和CSSOM tree，所以必须等两个tree都解析完成才会渲染，所以CSS会阻塞DOM的渲染

##### JS阻塞渲染
1. JS会阻塞DOM解析和渲染。
2. JavaScript 既可以读取和修改 DOM 属性，又可以读取和修改 CSSOM 属性。
所以，script 标签的位置很重要，在实际应用中我们通常把script标签放在body底部。

改变阻塞：
1. async
   async表示异步引入js
   文档按顺序解析，当遇到async的script时，脚本开始下载，同时文档也在同步解析，但脚本下载完成后如果文档未解析完毕则会暂停解析，先执行脚本
2. defer
   defer表示延迟执行引入的 JavaScript。
   文档按顺序解析，当遇到JavaScript脚本时开始下载，同时HTML也继续在解析，这两个过程是并行的。如果脚本下载完成，会等到文档解析完毕才会开始执行，而且按照标签出现的顺序执行




#### 详细过程
##### DOM阶段
将HTML代码解析为DOM，一个表示标签元素的树形结构

##### CSS阶段
得到能与DOM有效结合的css结构，把CSS代码解析为CSSOM，接着浏览器会计算出`computedStyle`，DOM中的每一个节点都有对应的`computedStyle`

##### LAYOUT阶段
我们得到了DOM，它可以表示标签的嵌套结构，又得到了computedStyle，它存储着样式信息并可以和DOM节点一一对应。于是，我们想法就很简单，把DOM和computedStyle结合起来。于是乎，就有了LAYOUT这个阶段

layout布局算法的输入就是DOM和computedStyle。
这一步主要就是确定元素的几何形状，坐标和尺寸。其中有以下几点要处理：

- 【块流】最简单的情况下，布局按dom的顺序，垂直的排列一个有一个块，也叫块流（block flow）
- 【行内流】还有文本和行内元素比如span，会在一行从左到右流动，叫做行内流，inline-flow。
- 【字体】布局也要计算字体。（使用HarfBuzz的文本形状库）
- 【包围矩形】布局可以为一个元素计算多种类型的边界矩形。 例如，当存在溢出时，布局将计算边框框的矩形和布局溢出矩形。如果节点的溢出是可滚动的，布局还计算滚动边界并为滚动条保留空间。最常见的可滚动DOM节点是document节点本身（dom树的根）。
- 【复杂布局】比如表格，或者由内容包围的浮动元素

最后这个阶段会生成Layout Tree，这个Layout Tree与DOM相关联，但是不是一一对应的，比如：

- 一个容器里面有了 div和span，span是行内元素，div是块级元素，于是，为了保证容器里面只有块级盒子，所以会在span的布局对象外面包裹一层匿名的块级盒子。这就是一个LayoutObject没有对应的DOM节点的情况。
- 以及如果一个盒子的计算属性中的display属性是none，那么它也没有对应的LayoutObject。



