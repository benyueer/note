# V8内存结构

## 内存区域划分
一个V8进程的内存通常由以下几块构成
1. 新生代内存区（new space）
   临时存储新对象，这个区域很小，但垃圾回收比较频繁，采用 Scavenge（Minor GC）算法进行垃圾回收
2. 老生代内存区（old space）
   这里只保存原始数据对象，这些对象没有指向其他对象的指针，两次 Minor GC 仍然存活的对象也会放到这里，采用标记清除&整理（Mark-Sweep & Mark-Compact, Major GC）算法进行垃圾回收
3. 大对象区（large object space）
   这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收不会移动大对象区
4. 代码区（code space）
   代码对象会被分配在这里，唯一拥有执行权限的内存
5. map区
   存放 cell 和 map ，每个区域都存放相同大小的元素，结构简单

## 内存页结构
堆内存中的空间都是由一组 Page （内存页）构成，每一个内存页都是由操作系统分配的连续内存快，除大对象空间以外，每一页的大小一般是 1MB

内存页的开头都是一个header，里面包括：
- 各种元数据和 flag （比如本页属于哪个空间），GC需要的各种统计数据，GC各个阶段在本页的进展情况等
- 一个 slots buffer，记录了所有指向本页内对象的指针，以节省回收时的一些扫描操作
- 一个 skip list，将本页划分为多个区并维护各个区的边界，用于快速搜索页上的对象

紧跟着header 的是一个 bitmap ，上面的每个 bit 对应页上的一个字，用于 marking， 前面的部分按32个字对齐后，剩余的空间才是用于存储对象的
新生代的内存页是连续的，而老生代的内存页是分散的，以链表的形式串联起来

## V8垃圾回收的特性简析
### stop-the-wrold
在执行垃圾回收的过程中，会暂停主线程的执行：由于JS的执行可能会产生新对象或者修改对象的引用，会造成对象的生存状态改变，假如没有准备相应的手段确保程序执行时不会修改正处于回收过程中的对象，就必须暂停执行确保对象能够安全回收

### generational
V8将堆内存分成了新生代和老生代，换言之，V8的垃圾回收器基于一个代际假说：即很多对象在内存中存在的时间很短，从垃圾回收的角度来看，很多对象一经分配内存空间随即就变成了不可访问的，而一旦存活下来的对象就很可能长期存在

### accurate
即准确式GC：V8预留所有的字的最后一位用于标记（tag）这个字中的内容的类型。1表示指针，0表示整数。这样给定一个内存中的字，它能通过查看最后一位快速的判断它包含的是指针还是整数，并且可以直接将整数存储在字中，无需先通过一个指针引用出来，节省空间。
由于V8能够通过查看字的最后一位快速的分配指针和整数，在GC的时候，V8能够跳过所有的整数，更快的沿着指针扫描堆中的对象。由于在GC的过程中，V8能够准确的分辨他所遍历到的每一块内存的内容属于什么类型，因此V8的垃圾回收器是准确式的。
与此相对的是保守式GC，即垃圾回收器因为某些设计导致无法确定内存中内容的类型，只能保守的先假设他们都是指针然后加以验证，以免回收不该回收的内存，因此可能误将数据当作指针，进而误认为一些对象仍然被引用，无法回收而浪费内存。同时因为保守的垃圾回收器没有十足的把握区分指针和数据，也就不能确保自己能够安全的修改指针，无法使用那些需要移动的对象更新指针的算法

## Minor GC(Scavenge)
用于新生代的垃圾回收，由于新生代的空间比较小，一般最大不超过16MB，因此新生代的垃圾回收会很频繁，他的处理方式必须非常快。

V8将新生代内存分为 nursery 和 intermediate 两个区域，对象初始时会被分配到 nursery 区域，经过一次GC后，如果对象任然存活，则会被复制到 intermediate 区域。再经过一次GC如果仍然存活，则会被移动到老生代。

### 基本步骤
Minor GC 在具体实现上，主要采用的是 Cheney 算法，可以分为标记、移动存活对象、更新对象指针三个大步骤，具体如下：
1. 在进行垃圾回收前，当前存储对象的内存页被标记为 From Space，另一块 semispace 中的内存页被标记为 To Space
2. 将执行栈、全局对象和“老生代指向新生代”的引用作为 roots
3. 开始扫描 roots ，找到存活对象（reachable objects），就将其从 From Space 复制到 To Space；进行复制时如果发现对象已经经历过一次GC，则会被移动到老生代。复制或移动完成后会在 From Space 原来的位置留下一个转发地址（forwarding address），后续如果扫描到该对象就可以直接使用这个新地址。
4. 复制或移动对象后，由于内存地址发生了变化，需要更新相应的指针以指向新的内存地址
5. 算法继续运行，对存活下来的对象上的引用继续执行类似3、4步骤的扫描和复制，直到没有新增的存活对象为止。此时 To Space 就充满了存活的对象，而From Space就可以清空了，下次再GC的时候可以直接拿来重新使用。整体上是一个广度优先遍历
6. 下一次GC时，From Space 和 To Space 的内存页会交换角色

### 细节问题
1. 晋升
   当对象存活过两次 Minor GC 后，会被移动到老生代，这个过程可以称为对象的晋升。除此之外，当对象第一次被复制到 To Space中时，如果发现其体积过大（To Space 的25%），也会直接晋升，而不会再复制到 To Space ，因为大对象的复制或移动成本是非常高的。
2. 触发时机
   新生代的空间一般不超过16MB，当需要在From Space为新对象分配空间，但剩余空间不足时，就会触发 Minor GC
3. write barrier
   在 Minor GC 初始进行扫描的引用Roots列表中，包含了从老生代指向新生代的引用，那么如何获取这些引用呢？把老生代整体扫描一遍肯定不现实，而V8正是通过 write barrier 来额外维护了从老生代指向新生代的引用，避免将老生代整体进行扫描
   写屏障是某些线程或进程写入某些内存位置时的阻塞
   具体到内存管理领域：写屏障用于增量或并发垃圾收集。它们还用于维护世代收集器的记忆集
   可以看到，write barrier 一般用于为分代回收器来维护 remembered sets
   remembered sets 是在两组对象之间保留一个单独的有趣引用列表的技术，因此您不必通过扫描来找到它们


## Major GC
Major GC 从整个堆中回收垃圾，主要分为3个阶段：标记（marking）、清除（sweeping）和整理（compacting）

### 标记
标记阶段就是找到可访问对象的一个过程，和 Minor GC 类似，标记是从一组对象的指针开始的，我们将其称之为根集（root set），这其中包含了执行栈和全局对象
V8使用三色标记法来进行对象标记：使用每个对象的两个标记位和一个现式的栈来实现标记。两个标记位编码三种颜色：白色（00）、灰色（10）和黑色（11）。白色代表这个对象可以被回收，黑色代表这个对象不能回收，而且它产生的所有引用都已经扫描完毕；灰色代表对象不能被回收，但它产生的引用还没有被扫描完。
扫描过程是一个深度优先遍历，最初所有的对象都是白色，意味着收集器还没有发现他们。当收集器发现一个对象时，将其标记为灰色并推入栈中。然后开始扫描该对象产生的所有引用并执行上述操作，这是一个递归的过程，当收集器访问完对象所有的引用并弹出对象时，灰色就会变成黑色。当栈上的所有对象都pop后，最后老生代的对象就只有黑色和白色两种了。

### 清除
Sweeping 就是扫描每一页的 marking bitmap， 找到死亡对象占用的连续区块，将这些块添加到随该页维护的一个freelist里。这个数据结构保存了页上可用于下次分配的内存位置，可以用于 compacting 、新生代晋升与老生代直接分配对象等需要在老生代中分配内存的场景。
V8中按照可用内存快大小的区间分出了多个 freelist，这样能更快找到合适的可用内存。

### 整理
Compacting 则是将页中的所有的存活对象都转移到另一页里，这样存活对象都被移走了的那一页就可以直接还给操作系统了
这种方法主要发生在某一页中死亡对象留下来的空洞比较多的时候，但也会有例外，比如这一页中的对象被太多其他页的对象引用的时候就不会compact，不然移动对象后更新所有指过来的指针将会是不小的开销


[参考](https://juejin.cn/post/6934645755080605710)